{"version":3,"file":"node_modules_raw-loader_dist_cjs_js_libs_remix-ws-templates_src_templates_semaphore_circuits_-5e0707.plugin-etherscan.1720620365076.js","mappings":";;;;;;;;;;AAAA,iEAAe,qBAAqB,mDAAmD,4BAA4B,gCAAgC,qCAAqC,oCAAoC,wBAAwB,yCAAyC,iDAAiD,8CAA8C,6BAA6B,GAAG,4CAA4C,0BAA0B,0BAA0B,yCAAyC,sCAAsC,6BAA6B,GAAG,uCAAuC,qCAAqC,qCAAqC,0BAA0B,yCAAyC,iDAAiD,+CAA+C,6BAA6B,GAAG,qLAAqL,qCAAqC,oCAAoC,4CAA4C,yCAAyC,gCAAgC,qCAAqC,2BAA2B,kCAAkC,sDAAsD,8DAA8D,4DAA4D,sBAAsB,qCAAqC,8EAA8E,oDAAoD,oEAAoE,qEAAqE,qEAAqE,qEAAqE,8DAA8D,wBAAwB,aAAa,MAAM,yDAAyD,+DAA+D,OAAO,qCAAqC,uFAAuF,oDAAoD,qDAAqD,GAAG,oBAAoB,wCAAwC,gBAAgB,CAAC","sources":["webpack:///../../libs/remix-ws-templates/src/templates/semaphore/circuits/semaphore.circom"],"sourcesContent":["export default \"pragma circom 2.0.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\ninclude \\\"./tree.circom\\\";\\n\\ntemplate CalculateSecret() {\\n    signal input identityNullifier;\\n    signal input identityTrapdoor;\\n    signal output out;\\n\\n    component poseidon = Poseidon(2);\\n\\n    poseidon.inputs[0] <== identityNullifier;\\n    poseidon.inputs[1] <== identityTrapdoor;\\n\\n    out <== poseidon.out;\\n}\\n\\ntemplate CalculateIdentityCommitment() {\\n    signal input secret;\\n\\n    signal output out;\\n\\n    component poseidon = Poseidon(1);\\n\\n    poseidon.inputs[0] <== secret;\\n\\n    out <== poseidon.out;\\n}\\n\\ntemplate CalculateNullifierHash() {\\n    signal input externalNullifier;\\n    signal input identityNullifier;\\n\\n    signal output out;\\n\\n    component poseidon = Poseidon(2);\\n\\n    poseidon.inputs[0] <== externalNullifier;\\n    poseidon.inputs[1] <== identityNullifier;\\n\\n    out <== poseidon.out;\\n}\\n\\n// credits to : https://github.com/semaphore-protocol/semaphore\\n// The current Semaphore smart contracts require nLevels <= 32 and nLevels >= 16.\\ntemplate Semaphore(nLevels) {\\n    signal input identityNullifier;\\n    signal input identityTrapdoor;\\n    signal input treePathIndices[nLevels];\\n    signal input treeSiblings[nLevels];\\n\\n    signal input signalHash;\\n    signal input externalNullifier;\\n\\n    signal output root;\\n    signal output nullifierHash;\\n\\n    component calculateSecret = CalculateSecret();\\n    calculateSecret.identityNullifier <== identityNullifier;\\n    calculateSecret.identityTrapdoor <== identityTrapdoor;\\n\\n    signal secret;\\n    secret <== calculateSecret.out;\\n\\n    component calculateIdentityCommitment = CalculateIdentityCommitment();\\n    calculateIdentityCommitment.secret <== secret;\\n\\n    component calculateNullifierHash = CalculateNullifierHash();\\n    calculateNullifierHash.externalNullifier <== externalNullifier;\\n    calculateNullifierHash.identityNullifier <== identityNullifier;\\n\\n    component inclusionProof = MerkleTreeInclusionProof(nLevels);\\n    inclusionProof.leaf <== calculateIdentityCommitment.out;\\n\\n    for (var i = 0; i < nLevels; i++) {\\n        inclusionProof.siblings[i] <== treeSiblings[i];\\n        inclusionProof.pathIndices[i] <== treePathIndices[i];\\n    }\\n\\n    root <== inclusionProof.root;\\n\\n    // Dummy square to prevent tampering signalHash.\\n    signal signalHashSquared;\\n    signalHashSquared <== signalHash * signalHash;\\n\\n    nullifierHash <== calculateNullifierHash.out;\\n}\\n\\ncomponent main {public [signalHash, externalNullifier]} = Semaphore(20);\";"],"names":[],"sourceRoot":""}