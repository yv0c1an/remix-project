{"version":3,"file":"node_modules_raw-loader_dist_cjs_js_libs_remix-ws-templates_src_templates_semaphore_circuits_-0387ff.plugin-etherscan.1720620365076.js","mappings":";;;;;;;;;;AAAA,iEAAe,qBAAqB,mDAAmD,6CAA6C,gDAAgD,wBAAwB,wCAAwC,qCAAqC,2BAA2B,qCAAqC,6BAA6B,mCAAmC,yBAAyB,wBAAwB,aAAa,MAAM,sDAAsD,uCAAuC,gCAAgC,yCAAyC,yCAAyC,2CAA2C,uCAAuC,wCAAwC,qDAAqD,mDAAmD,+CAA+C,OAAO,iCAAiC,GAAG,CAAC","sources":["webpack:///../../libs/remix-ws-templates/src/templates/semaphore/circuits/tree.circom"],"sourcesContent":["export default \"pragma circom 2.0.0;\\n\\ninclude \\\"circomlib/circuits/poseidon.circom\\\";\\ninclude \\\"circomlib/circuits/mux1.circom\\\";\\n\\ntemplate MerkleTreeInclusionProof(nLevels) {\\n    signal input leaf;\\n    signal input pathIndices[nLevels];\\n    signal input siblings[nLevels];\\n\\n    signal output root;\\n\\n    component poseidons[nLevels];\\n    component mux[nLevels];\\n\\n    signal hashes[nLevels + 1];\\n    hashes[0] <== leaf;\\n\\n    for (var i = 0; i < nLevels; i++) {\\n        pathIndices[i] * (1 - pathIndices[i]) === 0;\\n\\n        poseidons[i] = Poseidon(2);\\n        mux[i] = MultiMux1(2);\\n\\n        mux[i].c[0][0] <== hashes[i];\\n        mux[i].c[0][1] <== siblings[i];\\n\\n        mux[i].c[1][0] <== siblings[i];\\n        mux[i].c[1][1] <== hashes[i];\\n\\n        mux[i].s <== pathIndices[i];\\n\\n        poseidons[i].inputs[0] <== mux[i].out[0];\\n        poseidons[i].inputs[1] <== mux[i].out[1];\\n\\n        hashes[i + 1] <== poseidons[i].out;\\n    }\\n\\n    root <== hashes[nLevels];\\n}\";"],"names":[],"sourceRoot":""}